
= 分布式事务

2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有定时扫描补偿机制

2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务

* 2PC

** 二阶段提交，是一种强一致性设计

** 2PC 引入一个事务协调者的角色来协调管理各参与者

** 阶段：
*** 准备（投票）

    可以超时

*** 提交

    不能超时，失败不断重试

* 3PC
** 3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后新选举的协调者不知道当前应该提交还是回滚的问题。
** 阶段
*** 准备阶段 CanCommit

    准备阶段的变更成不会直接执行事务，而是会先去询问此时的参与者是否有条件接这个事务，因此不会一来就干活直接锁资源，使得在某些资源不可用的情况下所有参与者都阻塞着。

*** 预提交阶段 PreCommit
*** 提交阶段 DoCommit

    协调者挂了后，参与者超时后默认自动提交

* TCC
** 补偿性事务

    Confirm 和 Cancel 要满足幂等性
    针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。

** 阶段
*** Try 指的是预留，即资源的预留和锁定，注意是预留。
*** Confirm 指的是确认操作，这一步其实就是真正的执行了。

    采用 TCC 则认为 Confirm 阶段是不会出错的。
    即：只要 Try 成功，Conﬁrm 一定成功，若 Confirm 阶段真的出错了，需引入重试机制或人工处理，所以 Confirm 操作需要满足幂等性。

*** Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。

    采用 TCC 则认为 Cancel 阶段也是一定成功的。
    若 Cancel 阶段真的出错了，需引入重试机制或人工处理，所以 Cancel 操作需要满足幂等性。

* 本地消息表
** 最终一致性
** 将业务的执行和将消息放入消息表中的操作放在同一个事务中

* 消息事务
** 最终一致性
** RocketMQ

* 最大努力通知
** 最终一致性
